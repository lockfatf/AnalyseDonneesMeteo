---
title: "Rapport de Projet"
subtitle: "par Kévin Des Courières, Axel Kuehn et Florian Lock-Fat "
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Présentation du projet :

Voici notre rapport de projet sur les données météo. Nous avons travaillé à trois sur ce projet. Vous pouvez accèder aux codes sources du projet en R ainsi que le document RMarkdown et même ce rapport en PDF à l'adresse suivante : <https://github.com/lockfatf/AnalyseDonneesMeteo>.

# Préparations des données : 

## Imporation des librairies nécéssaires :

```{r library}
pacman::p_load(data.table,tidyverse,reshape2,FactoMineR,
               factoextra,rgl,caret,missMDA,dplyr,ggplot2)
```

## Imporation des données :

```{r data load}
# Chargement des donnees avec fread, plus intelligent que read.csv
# Climat
climat <- fread("Données/climat.201708.csv",data.table = F)
# Villes
villes <- fread("Données/postesSynop.csv",data.table=F)
# Merge des 2 jeux de données
climat <- merge(climat,villes,by="NUM_POSTE",all.x = T)
# Une ville avec aucune correspondance
climat$Nom[is.na(climat$Nom)] <- "Nom Inconnu"
# Renomage de l'indice par la variable NOM 
row.names(climat) <- climat$Nom
# Elimination de la variable NOM 
climat <- climat[,-c(55)]
# On retire les NA de notre varaible
climat <- climat[-which(is.na(climat$FXAB)),]
# Dimmension de notre jeu de données
dim(climat)
```
53 individus et 57 variables.

## Matrice de corélation : 

```{r}
# Construction de la matrice de corrélation
cormat <- round(cor(climat %>% select_if(is.numeric)),2)
# Melt : Transformation des données 
melted_cormat <- melt(cormat)
# Function
# Get lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Get upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}

# 
lower_tri <- get_lower_tri(cormat)
melted_cormat <- melt(lower_tri, na.rm = TRUE)

# Plot
ggplot(data = melted_cormat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low="blue", high="red", mid="white", midpoint=0,
                       limit=c(-1,1),space="Lab", name="Pearson\nCorrelation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45,vjust = 1,size = 10,hjust = 1)) +
  coord_fixed()

reorder_cormat <- function(cormat){
  # Use correlation between variables as distance
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
}

cormat[which(is.na(cormat[]))] <- 0

cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)
# Melt the correlation matrix
melted_cormat <- melt(upper_tri, na.rm = TRUE)
# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Pearson\nCorrelation") +
  theme_minimal() + # minimal theme
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 12, hjust = 1)) +
  coord_fixed()
# Print the heatmap
ggheatmap
```

### Exploration :
```{r}
# On suppose que toutes les donn?es et librairies ont ?t? charg?es dans l'?tape pr?c?dente (nettoyage)
featurePlot(x=preproc_impute$completeObs)
# ACP test pre-exploratoire
res_pca_vire <- PCA(preproc_impute$completeObs, ncp = dim(preproc_impute$completeObs)[2], scale.unit = TRUE, graph=F)
#plot3d(res_pca$ind$coord[,1:3])
#fviz_pca_ind(res_pca,axes=c(1,2),repel = T)
fviz_contrib(res_pca_vire,axes=c(1:6),choice="ind")
fviz_contrib(res_pca_vire,axes=c(1:6),choice="var")
contrib_ind <-fviz_contrib(res_pca_vire,axes=c(1:6),choice="ind")
```


